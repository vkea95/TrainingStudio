1. 图的生成树是包含图的所有顶点的无环连通子图。一副加权图的最小生成子树(MST)是它的一棵权值(树中所有边的权值之和)最小的生成树:
1.1 实现算法: Prim(从边着手) & Kruskal(从顶点着手)
1.2 应用场景:电路,航空,电力分配,图像分析
1.3 约定:权重可能为0或是负值!!!
        所有边的权重各不相同,这样才能保证MST的唯一
4.3.1 切分定理
图的一种切分是将其所有顶点分为两个分控且不重叠的两个集合。横切边是一个连接两个属于不同集合的顶点的边。
4.3.1.1 切分定理:在一副加权图中,给定任意的切分,它的横切边中权重最小者必然属于图的MST。
4.3.1.2 根据切分定理可实现贪心算法

4.3.2 加权无向图的数据类型
A.Edge
B.EdgeWeightedGraph
4.3.3 MST的API和测试用例

4.3.4 Prim算法
4.3.4.1 dataStructure: vertex, edge, 横切边的优先队列MinPQ(Edge)-->根据权重比较所有边
4.3.4.2 维护横切边集合
4.3.4.3 implement
A. lazyMode 相当于greedy算法: O(n)=ElogE
B. 瞬时mode PrimMST: O(n)=E log V
思想: 在将v加入MST后,只关心到非MST的顶点的权重最小的边,所以需要为到每个非MST的顶点建个数组存边的权重值,每加入个顶点后,随时更新该数组。
核心方法会自行更新图

最大的问题是,算法中用到的两个队列的实现方式,需要自己实现才能算全部完成--->这里面用了栈排序,sink,swim,exec等操作。
4.3.6 Kruskal算法
将边按照权重由小到大顺序,排序后,不停将边补充到MST中。O(n)=E log E
然后,通过UnionFind来比较两个顶点是否相互连接,若相互连接则直接跳过,若不是相互连接,则将2个顶点加入UnionFind,同时将该edge加入MST的边队列

ps:UF的源代码中,关于rank的使用很到位,用byte来表示rank,然后通过自行++的方式,来处理小树加到大树上的过程