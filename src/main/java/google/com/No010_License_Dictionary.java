package google.com;

/**
 * Created by tclresearchamerica on 7/20/16.
 * ****************************************************
 * Location:
 * https://mp.weixin.qq.com/s?__biz=MzA5MzE4MjgyMw==&mid=2649455128&idx=1&sn=5c058c46e00cdc0e1c8b906bc43d36bf&scene=0&key=77421cf58af4a65377780af9551def35eca07ccee4e814e899f480e654a3efeb4f029ad2986574a569de0e20a7ae2a0a&ascene=0&uin=MTc1NzcxMzQ0MA%3D%3D&devicetype=iMac+MacBookPro11%2C4+OSX+OSX+10.11.4+build(15E65)&version=11020201&pass_ticket=3okCzVcaNkpu4FC1YjZZ5XUaziVvHz6RccsDUWjCSbMiZJo%2B5e7ST%2FMhwVsz%2FbEi
 * ****************************************************
 * Description:
 * 給一个车牌号码(美国的)，以及一个dictionary，请找出dictionary里含有所有该车牌号码的所有英文字母(case insensitive)的最短字串
 * <p>
 * ex:
 * 车牌 RO 1287 ["rolling", "real", "WhaT", "rOad"] => "rOad"
 * <p>
 * follow up:
 * (1) 如果dictionary里有上百万个字，该如何加速
 * (2) 如果dictionary有上百万个字，然后給你上千个车牌号码，要你回传相对应的最短字串，该如何optimize?
 * 若有N个字，车牌长度为M，求问N+M算法。
 * <p>
 * 请问老师，原贴的讨论里面有提到将每个字母map到一个质数，一个单词就是所有字母表示质数的乘积。字典里的单词如果能被输入的字段除尽就是含有
 * 该输入字串的单词，然后求最短就好了。但是感觉这样还是需要每一个单词都要扫一遍字典，复杂度并没有降低。
 * ****************************************************
 * Analysis:
 * 有的同学认为，这道题可以用 trie 解决，但其实用 trie 并不能解决。
 * <p>
 * 因为这个题说的是包含单词里的所有字母就好了，并没有要求顺序。也就是说从例子中来看，“orad” 也是包含 "RO" 的。
 * <p>
 * 首先这类问题，给一个dictionary的，都是需要对 dictionary 做一些预处理的，因为dictionary又不会随时变化。既然是google的题，
 * 那么这个题多半就跟倒排索引有关系。一个直观的解决办法就是建立倒排索引。
 * <p>
 * 比如 "Access" 这个单词，出现了 a, c, e, s 四个字母。所以把Access 分别放入 a, c, e, s 的队列中。
 * <p>
 * 然后假如你来了一个车牌，包含字母'ace'，如何找到 Access呢？方法是，把 a 的倒排拿出来，c的拿出来，e的拿出来。然后做一次归并。
 * 把同时出现在这三个字母里的倒排里的单词找到。为了加速算法，倒排在建立的时候，就可以先按照长度排序，然后相同长度的按照字母序排序。
 * 这样在归并的时候找到的第一个在三个字母的倒排队列中出现的单词，就是答案。
 * <p>
 * 你可能会意识到，这种方法在某些情况下还是很慢，因为比如上百万个单词，一共只有26个不同的字母，那么平均下来，每个字母也有 1m/26 个
 * 单词包含它。归并的时候效率并不高。那么怎么解决呢？上面的算法的key只有一个字母，自然这个1m/26的分母比较小。我们要想办法把这个分母变大。
 * 答案是，可以用2个字母作为key。
 * <p>
 * 以 Access 为例，出现的字母有 aces，那么把 ac, ae, as, ce, cs, es 作为倒排的key，把Access 放到这6个key的倒排列表中。
 * 当我们需要查询 ace 被哪些单词包含的时候，我们就可以归并 ac 和 e 的倒排表。这就比 并 a, c, e 的三个倒排表要快了。
 * <p>
 * 再进一步，你可以用3个字母作为 key, access => {ace, acs, ces, aes}，这样一口气就能找到 ace 了，无需归并。
 * <p>
 * 进一步分析，你会发现这是一个 tradeoff，就是并不是用越多的字母作为key就越好。假如单词的平均长度是 L，那么C(L,1)是有多少个1元的key，
 * C(L,2)是有多少个2元的key（基本是L^2的级别 ），C(L,3)是有多少个3元的key。。。
 * <p>
 * 所以字母越多，一个单词被重复扔到各个倒排列表中的机会就越多。需要的存储空间也就越大。介于车牌的字母不是很多，
 * 我觉得差不多到3元的key就差不多可以了。
 * ****************************************************
 * ****************************************************
 * ****************************************************
 */
public class No010_License_Dictionary {
}
