package leetcode.com.easy;

/**
 * Created by tclresearchamerica on 7/8/16.
 * ****************************************************
 * Location:
 * https://leetcode.com/problems/sum-of-two-integers/
 * ****************************************************
 * Description:
 * Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.
 * <p>
 * Example:
 * Given a = 1 and b = 2, return 3.
 * ****************************************************
 * Thoughts:
 * 想来是和补码反码之类的码相关吧?
 * Reference:
 * http://www.cnblogs.com/kiven-code/archive/2012/09/15/2686922.html
 * ****************************************************
 * Explaination:
 * 分析上面的真值表就可以总结出，多位二进制加法的规则了。如下：
 * sum = (x XOR y) XOR icarry
 * ocarry = (x AND y) OR (icarry AND (x XOR y)) = (x AND y) OR (y AND icarry) OR (icarry AND x)
 * <p>
 * 利用以上的分析结果，可将x, y的每一位级联计算，先计算x和y的第零位，该位的输入进位(icarry=0)为零，将计算所得的进位传入到x和y的第一
 * 位的计算中，依次进行直到计算完最高位为止，此时将每一位计算所得的和连接起来就是最终的和，最高位计算所得的进位就是最终的进位。至此，
 * 二进制的加法应该没有什么问题了，很简单XOR为和，AND为进位。计算机中的加法也是使用这种原理来实现的，有兴趣的可以看看《编码的奥秘》这本书。
 * <p>
 * (3).在C++中实现加法
 * 通过以上分析似乎用代码实现计算机加法的方法已经很明了了，将参加计算的x,y分别一位一位的进行XOR和AND，然后将结果打印出来，OK完事了，
 * 很简单不是吗？但问题是如果将x和y的每一位拆分，然后记录每一位计算后所得的进位，然后做为下一位的进位输入。仔细想想又似乎是问题多多啊，
 * 烦啊。其实也不然我们用代码实现的时候已经不需要再将每一位拆分计算了(如果你确实像模拟计算机硬件的执行过程也可以这么做，只是这样做很麻烦，
 * 而且计算的速度比较慢)。首先，我们通过对x和y进行&位运算，得出每一位上的进位。然后对x和y进行^位运算，得出没有加进位的和。
 * 最后将所得的和当做新的x，所得的进位往左移一位(第零位的进位输入为0)当做新的y，继续做上面的步骤，直到进位为0，
 * 此时x中保存的就是我们要求的x和y的和了。
 * ****************************************************
 * Thought:
 * 1.看来四则运算也要运用到面试题中了,有时间还要搞搞其余的3种数学运算方法
 * ****************************************************
 * ****************************************************
 * ****************************************************
 * ****************************************************
 * ****************************************************
 */
public class No371_Sum_of_Two_Integers {
    public int getSum(int a, int b) {
        int sum = a;
        int carry = b;
        while (carry != 0) {

            int tmps = sum;
            sum = tmps ^ carry;
            carry = (tmps & carry) << 1;
        }
        return sum;
    }
}
