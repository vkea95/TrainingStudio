package leetcode.com.pickup1.medium;

/**
 * Created by tclresearchamerica on 7/10/16.
 * ****************************************************
 * Location:
 * https://leetcode.com/problems/bitwise-and-of-numbers-range/
 * ****************************************************
 * Description:
 * Given a range [m, n] where 0 <= m <= n <= 2147483647, return the bitwise AND of all numbers in this range, inclusive.
 * For example, given the range [5, 7], you should return 4.
 * ****************************************************
 * Thoughts:
 * 1.所以这道题是求m~n之间所有的数的and操作后,得到的数值是多少.所以要寻找相应的规律呢
 * 2.在白板上推演,感觉不是保留了最高位,就是零才是答案
 * 3.ref:http://www.cnblogs.com/csonezp/p/4587392.html
 * 这里的另一种方式，主要用到了n&(n-1)这个式子。初看上去你可能会很迷茫，因为从字面上确实看不出这个式子跟这个题目有什么关系。当然，
 * 如果你脑子中二进制各种运算和十进制一样熟悉，那你肯定会知道，这个式子的作用就是消去n的最低位的1。讲解可以看这里
 * 按位运算，所有数字自然要按二进制形式表达。一组数字按位与时，只有所有数字这一位上都为1时，结果才会为1。如果m=n,那自然结果就是m.下面讨论m!=n的情况。
 * <p>
 * 让我们从最低位开始。
 * 如果这一组数字的最低位不相同的话，那这一位就肯定会被消掉，变成0.如果m!=n,那最低位肯定是要被消掉的，因为最低位肯定会是一个0，
 * 一个1.这时，我们可以将m和n都右移一位，将最后一位忽略。
 * <p>
 * 此时，又有了新的一组m和n。如果此时m=n,那结果就是m了。如果不是的话，那可以继续上一段的过程，将m和n右移一位。
 * <p>
 * 重复上述操作，直到m=n。这个时候，从低位往高位所有进行与操作后结果为0的位数都已经被消掉，而高位的数字进行与操作不会发生变化，
 * 此时的m或者n再向左移动之前移动的位数，得到的就是这一组数字按位与后的结果。
 * ****************************************************
 * 那么这道题其实并不难，我们先从题目中给的例子来分析，[5, 7]里共有三个数字，分别写出它们的二进制为：
 * <p>
 * 101　　110　　111
 * <p>
 * 相与后的结果为100，仔细观察我们可以得出，最后的数是该数字范围内所有的数的左边共同的部分，如果上面那个例子不太明显，
 * 我们再来看一个范围[26, 30]，它们的二进制如下：
 * <p>
 * 11010　　11011　　11100　　11101　　11110
 * <p>
 * 发现了规律后，我们只要写代码找到左边公共的部分即可，我们可以从建立一个32位都是1的mask，然后每次向左移一位，比较m和n是否相同，
 * 不同再继续左移一位，直至相同，然后把m和mask相与就是最终结果，代码如下：
 * <p>
 * <p>
 * ****************************************************
 * Time: 20mins
 * Beat: 57%
 * Bug:0
 * ****************************************************
 * Hindsight:
 * 自己尝试着进行推导,但是没有找到规律,这才是大问题呢!!!所以,以后在进行推导的时候,要注意发现这样的规律才好,什么最左侧的相同的...
 * 否则很难找到答案的啦
 * ****************************************************
 * ****************************************************
 * ****************************************************
 * ****************************************************
 * ****************************************************
 * ****************************************************
 * ****************************************************
 * ****************************************************
 */
public class No201_Bitwise_AND_of_Numbers_Range {
    public int rangeBitwiseAnd(int m, int n) {
        if (n == m) return n;
        if (n - 1 == m) return n & m;

        return rangeBitwiseAnd(m >> 1, n >> 1) << 1;
    }

    public int rangeBitwiseAnd_slow_2(int m, int n) {
        while (n > m) {
            n &= (n - 1);
        }
        return n;
    }

    public int rangeBitwiseAnd_slow(int m, int n) {
        int i = 0;
        while (m != n) {
            m >>= 1;
            n >>= 1;
            i++;
        }
        return m << i;
    }
}
