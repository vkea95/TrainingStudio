difficulty: No.112,114,116, 199,200需要二刷 @white board, 210,279, 188, 547, 128,685!!!,173,218,307,329
0912
1. robber house:
dp数组，
2. 数组
数学公式，C4 2
3. max square: n*m 要取个最小值
4. m*n 矩阵多少种走法
0*0-> (m-1)*(n-1)
优化：

用一个1维的数组，去进行优化
4.edit distance
2维数组，删减字符
5.到达某点的时候，等差数列个数
可以优化成一个count的公式，


6.sky line
7. combination

0913：
1. 后续遍历BST
--->再次和晓波确认下解法。
2. lintcode 博弈问题：两个人选数，看谁拿到的数量总值最大。-->要原题

0924:
NO.128: K次买卖股票,这个要把思路理解了,就可以破解股票III的问题了。

0925:
No.106:类似于105,但是不能套用,否则计算postOrder的下标时候,会需要重新计算,因为start和end都需要所以容易算错,此时可以定义一个全局的postEnd,
通过先右后左的方式遍历,完成构建
N0.107:虽然简单,但是队列解法的那个思路,可以当做取队列中间状态的一个常用方法,记录下来
No.110:这个确实忘记如何破解了,只知道计算树的叶子节点高度的差值是否大于1了,其实就是某节点下面左右节点高度的差的问题
No.111, No.112, No.113: 都是一个套路,就是要利用递归调用的模板,将计算的内容添加进去
No.114:有点难度,递归的方法理解起来比较简单,但是推理起来,有不清晰的地方;
非递归方法:将当前节点的右孩子,挂到左孩子的最右侧,然后左孩子替代右孩子的位置,左孩子的位置设为null;然后当前节点指向新的右孩子,继续while处理
No.116: 这个方法的问题是,如果中间的一个节点没有左孩子,那他左侧那个邻居孩子的next指针,指向null? 算法看上去指向的是null,
-->完美平衡二叉树,所以,以上假定是不存在的,但是在No.117要注意
No.117

0927
DFS:
No.98,
No.124:想法很赞,拆开了理解,也就没那么难,但是能够想到还是很赞的

sort-->tree->dfs
0929:
No.133, 199
==> Tree的三种遍历方式的非递归实现,要烂熟于心
0930
No.200-->我的那个解法的bug没有解开!!!!
No.207-->course schedule 未开始
1001
No.210,279

1003 -->union-find
No.128,547, 684,685
1006 -->HashMap
No.001

1007
No.146,155,173
1008:
No.218,307,329